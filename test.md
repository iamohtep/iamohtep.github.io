## Tag 3
---
## Postgresqsl Transaction - Write Ahead Log (WAL), Checkpoint
![](images/7.png)

## Checkpoint
in postgresql.conf

![](images/8.png)

## Shared Buffers / IO Cache
!!! # 25 bis 40% des RAM
 in postgresql.conf

shared_buffers = 128MB    #default

### 2Q ClockSweep
Blöcke, die häufig genutzt wird, werden ins andere Hälfte des IO Cache

## Bulk vs einzelne Transaction

````sql
BEGIN
INSERT INTO t_test VALUES (10, 20);
..
.. 1000x
COMMIT
````
Versus

````sql
INSERT INTO t_test VALUES (10, 20);
..
.. 1000x
````

#### soft commit
![](images/9.png)

----
## Replikation / Backup
!!! als Übung wurde die DB nicht über systemd gestartet

manuelles Starten
````sql
pg_ctl -D /var/lib/pgsql/14/data/ start
ps -ef | grep post
root       82709   81274  0 11:18 pts/0    00:00:00 sudo su - postgres
root       82711   82709  0 11:18 pts/0    00:00:00 su - postgres
postgres   82712   82711  0 11:18 pts/0    00:00:00 -bash
postgres   82846       1  0 11:19 ?        00:00:00 /usr/pgsql-14/bin/postgres -D /var/lib/pgsql/14/data
postgres   82847   82846  0 11:19 ?        00:00:00 postgres: logger
postgres   82849   82846  0 11:19 ?        00:00:00 postgres: checkpointer
postgres   82850   82846  0 11:19 ?        00:00:00 postgres: background writer
postgres   82851   82846  0 11:19 ?        00:00:00 postgres: walwriter
postgres   82852   82846  0 11:19 ?        00:00:00 postgres: autovacuum launcher
postgres   82853   82846  0 11:19 ?        00:00:00 postgres: stats collector
postgres   82854   82846  0 11:19 ?        00:00:00 postgres: logical replication launcher
postgres   82965   82712  0 11:22 pts/0    00:00:00 ps -ef
postgres   82966   82712  0 11:22 pts/0    00:00:00 grep --color=auto post
````

### Übung
Replikation ins **/tmp/replikationbak** der Instanz **-h localhost** mit **--checkpoint=fast** und konfiguriere die Replikation **-R**
````sql
[postgres@tn07-purple data]$ pg_basebackup -D /tmp/replikationbak -h localhost --checkpoint=fast -R
````
Starte die /tmp/replikationbak mit READONLY
````sql
[postgres@tn07-purple data]$ pg_ctl -D /tmp/replikationbak/ -o "--port=6000" start
waiting for server to start....2022-09-07 11:50:39.792 CEST [83815] LOG:  redirecting log output to logging collector process
2022-09-07 11:50:39.792 CEST [83815] HINT:  Future log output will appear in directory "log".
 done
server started
[postgres@tn07-purple data]$
````

Zweite Replikation
````sql
[postgres@tn07-purple data]$ pg_basebackup -D /tmp/third -h localhost -p 6000 --checkpoint=fast -R
[postgres@tn07-purple data]$ pg_ctl -D /tmp/third/ -o "--port=7000" start
waiting for server to start....2022-09-07 12:01:24.282 CEST [84067] LOG:  redirecting log output to logging collector process
2022-09-07 12:01:24.282 CEST [84067] HINT:  Future log output will appear in directory "log".
 done
server started
````
!!! Replizierte DB wird als READONLY konfiguriert
````sql
[postgres@tn07-purple data]$ cat /tmp/testsystem/postgresql.auto.conf
# Do not edit this file manually!
# It will be overwritten by the ALTER SYSTEM command.
[postgres@tn07-purple data]$
````

um WRITABLE zu ermöglichen -> promote
```sql
[postgres@tn07-purple data]$ pg_ctl -D /tmp/second/ promote
waiting for server to promote.... done
server promoted
[postgres@tn07-purple data]$
```

!!! # mit -R wird die Replizierte DB als WRITABLE konfiguriert
```sql
[postgres@tn07-purple data]$ cat /tmp/testsystem/postgresql.auto.conf
# Do not edit this file manually!
# It will be overwritten by the ALTER SYSTEM command.
primary_conninfo = 'user=postgres passfile=''/var/lib/pgsql/.pgpass'' channel_binding=prefer host=localhost port=5432 sslmode=prefer sslcompression=0 sslsni=1 ssl_min_protocol_version=TLSv1.2 gssencmode=prefer krbsrvname=postgres target_session_attrs=any'
```
```sql
[postgres@tn07-purple data]$ pg_basebackup -D /tmp/testsystem -h localhost --checkpoint=fast
[postgres@tn07-purple data]$ pg_ctl -D /tmp/testsystem/ -o "--port=9000" start
waiting for server to start....2022-09-07 12:17:58.562 CEST [84592] LOG:  redirecting log output to logging collector process
2022-09-07 12:17:58.562 CEST [84592] HINT:  Future log output will appear in directory "log".
 done
server started
```

### Replikation eingepackt
-F format
-t tar - Write the output as tar files in the target directory. The main data directory's contents will be written to a file named base.tar

> [postgres@tn07-purple data]$ pg_basebackup -h localhost -Ft -D /tmp/backup --checkpoint=fast
```sql
[postgres@tn07-purple ~]$ ll /tmp/backup/
total 88268
-rw-------. 1 postgres postgres   184498 Sep  7 12:25 backup_manifest
-rw-------. 1 postgres postgres 73416704 Sep  7 12:25 base.tar
-rw-------. 1 postgres postgres 16778752 Sep  7 12:25 pg_wal.tar
```

-C
       --create-slot
           Specifies that the replication slot named by the --slot option should be created before starting the backup. An error is raised if the
           slot already exists.

### Replikation Slots
````sql
[postgres@tn07-purple ~]$ pg_basebackup -h localhost -D /tmp/data --checkpoint=fast -R -C -S myslot


[postgres@tn07-purple ~]$ psql test
psql (14.5)
Type "help" for help.

test=# \x
Expanded display is on.
test=# select * from pg_replication_slots;
-[ RECORD 1 ]-------+-----------
slot_name           | myslot
plugin              |
slot_type           | physical
datoid              |
database            |
temporary           | f
active              | f
active_pid          |
xmin                |
catalog_xmin        |
restart_lsn         | 0/AF000000
confirmed_flush_lsn |
wal_status          | reserved
safe_wal_size       |
two_phase           | f

test=#
````
---
## Recovery
#### Point in time Recovery
1. Szenario - einfaches export/import 00:00 bis 06:00
![](images/10.png)
````
[postgres@tn07-purple ~]$ pg_dump test > /tmp/backup.sql
[postgres@tn07-purple ~]$ pg_dump test > /tmp/backup.sql
[postgres@tn07-purple ~]$
[postgres@tn07-purple ~]$ createdb xyz
[postgres@tn07-purple ~]$ psql xyz < /tmp/backup.sql
````

2. Szenario - mit WAL (konsistenz) - Point In Time
    ![](images/12.png)
   wichtige Einstellung in postgres.conf
   
   ````bash
    archive_mode = on               # enables archiving; off, on, or always
                                    # (change requires restart)
    archive_command = 'cp %p /tmp/archive/%f'   # command to use to archive a logfile segment
                                    # placeholders: %p = path of file to archive
                                    #               %f = file name only
                                    # e.g. 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'
    #archive_timeout = 0            # force a logfile segment switch after this
                                    # number of seconds; 0 disables

    # - Archive Recovery -

    # These are only used in recovery mode.

    restore_command = 'cp /tmp/archive/%f %p'   # command to use to restore an archived logfile segment

    recovery_target_time = '2022-09-07 15:05'   # the time stamp up to which recovery will proceed
                                                # (change requires restart)
   ````
   ![](images/11.png)
   
   !!! # Start den neuen DB-Server
   !!! # Bei Point-in-time restore muss die DB 'promoted' werden
   !!! # Die postgresql.conf bzlg. archive eventuell anpassen

   ````sql
   pg_basebackup -h localhost -D /tmp/backup --checkpoint=fast
   ````

!!! # Alt: pgBackRest -> automatisiertes Backup / Restore
#### show archive/restore command settings
```sql
test=# show archive_command;
    archive_command
-----------------------
 cp %p /tmp/archive/%f
(1 row)

test=# show restore_command;
    restore_command
-----------------------
 cp /tmp/archive/%f %p
(1 row)

test=# \df *is*rec*
                               List of functions
   Schema   |       Name        | Result data type | Argument data types | Type
------------+-------------------+------------------+---------------------+------
 pg_catalog | pg_is_in_recovery | boolean          |                     | func
 pg_catalog | pg_mcv_list_recv  | pg_mcv_list      | internal            | func
 pg_catalog | pg_ndistinct_recv | pg_ndistinct     | internal            | func
(3 rows)

test=# select pg_is_in_recovery();
 pg_is_in_recovery
-------------------
 f
(1 row)
```

#### Flexibilität mit dem Backup/Restore auf FS Ebene
![](images/13.png)

!!! # TIP: Patroni (automatic failover)